# Redis Event Streaming Design Specification

## 1. Unified Event Format Schema

Based on the existing codebase patterns, here's the recommended standardized event format:

### Standard Event Structure

```typescript
{
  // Core Identification Fields
  eventId: string,              // UUID v4 (e.g., from uuidv4())
  messageId: string,             // Redis-generated message ID (auto-generated by XADD)
  streamId: string,              // Stream key (e.g., "crm:sync:role:role_updated")
  
  // Event Classification
  eventType: string,             // Dot-notation: "role.permissions_changed", "user.created"
  entityType: string,            // Entity category: "role", "user", "organization"
  entityId: string,             // ID of the affected entity
  action: string,                // Action verb: "created", "updated", "deleted", "permissions_changed"
  
  // Multi-tenancy
  tenantId: string,             // Required: UUID format tenant identifier
  
  // Timestamps
  timestamp: string,             // ISO8601 format (e.g., new Date().toISOString())
  sourceTimestamp?: string,      // Original event timestamp if different
  
  // Source Information
  sourceApp: string,             // "wrapper-api", "crm", "hrms"
  version: string,               // Event schema version (e.g., "1.0")
  
  // Event Payload
  data: object | string,         // Event-specific data (object or JSON string)
  
  // Processing Metadata
  metadata: {
    correlationId: string,       // For tracing related events
    retryCount: number,          // Number of retry attempts (default: 0)
    publishedBy?: string,         // User/system that triggered the event
    ...additionalMetadata        // Event-specific metadata
  }
}
```

### Rationale

1. **Compatibility**: Aligns with existing patterns in `redisStreamsPublisher.js` and `redis.js`
2. **Flexibility**: Supports both object and JSON string formats for `data` (handles wrapper API requirements)
3. **Traceability**: Includes `correlationId` and `eventId` for event tracking
4. **Multi-tenancy**: Explicit `tenantId` field for tenant isolation
5. **Versioning**: `version` field allows schema evolution

### Event Type Naming Convention

Use dot-notation for consistency:
- `role.permissions_changed`
- `role.created`
- `role.updated`
- `role.deleted`
- `user.created`
- `user.deactivated`
- `organization.created`

---

## 2. Role Permissions Change Event Structure

### Recommended Data Structure

```typescript
{
  // Event envelope (from unified format above)
  eventId: "uuid-v4",
  eventType: "role.permissions_changed",
  entityType: "role",
  entityId: "role-id-uuid",
  tenantId: "tenant-uuid",
  timestamp: "2024-01-15T10:30:00.000Z",
  sourceApp: "wrapper-api",
  version: "1.0",
  
  // Event-specific data
  data: {
    roleId: string,                    // Required: UUID of the role
    roleName: string,                  // Required: Human-readable role name
    permissions: {                      // Required: Nested permissions structure
      [application: string]: {         // e.g., "crm", "hrms"
        [module: string]: {            // e.g., "leads", "employees"
          [operation: string]: boolean // e.g., "read": true, "create": false
        }
      }
    },
    // OR flat permissions array (for backward compatibility)
    flatPermissions?: string[],        // e.g., ["crm.leads.read", "crm.leads.create"]
    
    // Role metadata
    description?: string,
    isActive: boolean,                 // Default: true
    scope?: string,                    // "organization", "global", "department"
    priority?: number,                 // Role priority/order
    
    // Audit fields
    updatedBy?: string,                // User ID who made the change
    updatedAt?: string,                // ISO8601 timestamp
    
    // Additional role properties
    restrictions?: {                   // Time/IP restrictions
      allowedIPs?: string[],
      allowedTimeRanges?: Array<{start: string, end: string}>,
      // ... other restrictions
    },
    metadata?: {                       // Custom metadata
      tags?: string[],
      templateId?: string,
      // ... other metadata
    }
  },
  
  // Processing metadata
  metadata: {
    correlationId: "role_permissions_{roleId}_{timestamp}",
    retryCount: 0,
    version: "1.0",
    sourceTimestamp: "2024-01-15T10:30:00.000Z",
    sourceApp: "wrapper-api",
    publishedBy?: string                // User/system that published
  }
}
```

### Stream Key Format

For role permissions changes, use:
```
crm:sync:role:role_permissions_changed
```

**OR** for backward compatibility with existing code:
```
crm:sync:role_permissions
```

### Rationale

1. **Nested Permissions**: Matches existing `CrmRole` model structure (`permissionsStructure`)
2. **Backward Compatibility**: Supports both nested object and flat array formats
3. **Audit Trail**: Includes `updatedBy` and `updatedAt` for compliance
4. **Flexibility**: Optional fields allow gradual adoption

---

## 3. Consumer Group Management

### Recommended Strategy: **Hybrid Approach**

Based on `crm-consumer-runner.js` patterns:

### Option A: One Consumer Group Per Stream Type (Recommended)

```typescript
// Stream-specific consumer groups
const consumerGroups = {
  'crm:sync:user:user_created': 'crm-consumers:user-events',
  'crm:sync:user:user_deactivated': 'crm-consumers:user-events',
  'crm:sync:role:role_created': 'crm-consumers:role-events',
  'crm:sync:role:role_updated': 'crm-consumers:role-events',
  'crm:sync:role:role_permissions_changed': 'crm-consumers:role-events',
  'crm:sync:organization:org_created': 'crm-consumers:org-events',
  // ... etc
};
```

**Benefits:**
- Better isolation between event types
- Easier to scale specific event types independently
- Clearer monitoring and debugging
- Matches Redis Streams best practices

### Option B: Tenant-Specific Consumer Groups (Current Pattern)

```typescript
// Tenant-specific consumer groups (current implementation)
const consumerGroup = `crm-consumers:${tenantId}`;
const consumerName = `${baseConsumerName}-${tenantId}`;
```

**Benefits:**
- Tenant isolation
- Easier tenant-specific scaling
- Matches current multi-tenant architecture

### Recommended: **Combined Approach**

```typescript
// Format: {stream-type}:{tenant-id}
const consumerGroup = `crm-consumers:${streamType}:${tenantId}`;
const consumerName = `${baseConsumerName}-${streamType}-${tenantId}`;

// Examples:
// - crm-consumers:role-events:tenant-123
// - crm-consumers:user-events:tenant-123
// - crm-consumers:org-events:tenant-123
```

**Consumer Name Structure:**
```
{app}-{stream-type}-{tenant-id}-{instance-id}
```

Example: `crm-role-events-tenant-123-instance-001`

### Consumer Group Creation Strategy

```typescript
async createConsumerGroups(streams: string[], tenantId: string) {
  const streamTypeMap = {
    'crm:sync:user': 'user-events',
    'crm:sync:role': 'role-events',
    'crm:sync:organization': 'org-events',
    'crm:sync:credits': 'credit-events',
  };
  
  for (const stream of streams) {
    const streamType = this.getStreamType(stream, streamTypeMap);
    const consumerGroup = `crm-consumers:${streamType}:${tenantId}`;
    
    try {
      await this.redisClient.xGroupCreate(
        stream,
        consumerGroup,
        '0', // Start from beginning
        { MKSTREAM: true }
      );
    } catch (error) {
      if (error.message.includes('BUSYGROUP')) {
        // Already exists, continue
      } else {
        throw error;
      }
    }
  }
}
```

---

## 4. Event Validation Rules

### Validation Schema

```typescript
interface ValidationRules {
  // Required Fields
  requiredFields: {
    eventId: (value: any) => boolean;      // Must be valid UUID v4
    eventType: (value: any) => boolean;    // Must match whitelist
    tenantId: (value: any) => boolean;     // Must be valid UUID format
    entityId: (value: any) => boolean;     // Must be non-empty string
    timestamp: (value: any) => boolean;   // Must be valid ISO8601
    data: (value: any) => boolean;         // Must be object or valid JSON string
  };
  
  // Format Validation
  formatValidation: {
    eventId: RegExp;                       // UUID v4 regex
    tenantId: RegExp;                      // UUID regex
    timestamp: RegExp;                     // ISO8601 regex
    eventType: string[];                   // Whitelist of allowed event types
  };
  
  // Data Structure Validation
  dataStructureValidation: {
    [eventType: string]: (data: any) => boolean; // Event-specific validation
  };
}
```

### Implementation

```typescript
class EventValidator {
  private readonly UUID_V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  private readonly ISO8601_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/;
  
  private readonly ALLOWED_EVENT_TYPES = [
    'role.created',
    'role.updated',
    'role.deleted',
    'role.permissions_changed',
    'user.created',
    'user.deactivated',
    'organization.created',
    'credit.allocated',
    'credit.config_updated',
    // ... add more as needed
  ];
  
  validateEvent(event: any): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // 1. Required Fields Validation
    if (!event.eventId) errors.push('Missing required field: eventId');
    if (!event.eventType) errors.push('Missing required field: eventType');
    if (!event.tenantId) errors.push('Missing required field: tenantId');
    if (!event.entityId) errors.push('Missing required field: entityId');
    if (!event.timestamp) errors.push('Missing required field: timestamp');
    if (!event.data) errors.push('Missing required field: data');
    
    // 2. Format Validation
    if (event.eventId && !this.UUID_V4_REGEX.test(event.eventId)) {
      errors.push('Invalid eventId format: must be UUID v4');
    }
    
    if (event.tenantId && !this.UUID_V4_REGEX.test(event.tenantId)) {
      errors.push('Invalid tenantId format: must be UUID');
    }
    
    if (event.timestamp && !this.ISO8601_REGEX.test(event.timestamp)) {
      errors.push('Invalid timestamp format: must be ISO8601');
    }
    
    if (event.eventType && !this.ALLOWED_EVENT_TYPES.includes(event.eventType)) {
      errors.push(`Invalid eventType: ${event.eventType} not in whitelist`);
    }
    
    // 3. Data Format Validation
    if (event.data) {
      if (typeof event.data === 'string') {
        try {
          JSON.parse(event.data);
        } catch (e) {
          errors.push('Invalid data format: must be valid JSON string');
        }
      } else if (typeof event.data !== 'object') {
        errors.push('Invalid data format: must be object or JSON string');
      }
    }
    
    // 4. Event-Specific Validation
    const eventSpecificErrors = this.validateEventSpecificData(event.eventType, event.data);
    errors.push(...eventSpecificErrors);
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  private validateEventSpecificData(eventType: string, data: any): string[] {
    const errors: string[] = [];
    
    // Parse data if it's a string
    let parsedData = data;
    if (typeof data === 'string') {
      try {
        parsedData = JSON.parse(data);
      } catch (e) {
        return ['Invalid data JSON format'];
      }
    }
    
    switch (eventType) {
      case 'role.permissions_changed':
        if (!parsedData.roleId) errors.push('role.permissions_changed: missing roleId');
        if (!parsedData.roleName) errors.push('role.permissions_changed: missing roleName');
        if (!parsedData.permissions && !parsedData.flatPermissions) {
          errors.push('role.permissions_changed: missing permissions or flatPermissions');
        }
        break;
        
      case 'user.created':
        if (!parsedData.userId) errors.push('user.created: missing userId');
        if (!parsedData.email) errors.push('user.created: missing email');
        break;
        
      // Add more event-specific validations as needed
    }
    
    return errors;
  }
}
```

### Validation Points

1. **Publisher Side** (Before publishing):
   - Validate event structure before `XADD`
   - Reject invalid events immediately
   - Log validation failures

2. **Consumer Side** (Before processing):
   - Validate on message receipt
   - Move invalid messages to dead-letter queue
   - Don't acknowledge invalid messages (let them retry or expire)

3. **Middleware Layer**:
   - Centralized validation service
   - Reusable across all publishers/consumers

### Error Handling

```typescript
// Invalid events should be:
// 1. Logged with full event details
// 2. Sent to dead-letter stream (optional)
// 3. Not acknowledged (for retry) OR acknowledged with error flag
// 4. Alerted to monitoring system

if (!validationResult.valid) {
  console.error('‚ùå Invalid event received:', {
    eventId: event.eventId,
    eventType: event.eventType,
    errors: validationResult.errors,
    event: JSON.stringify(event, null, 2)
  });
  
  // Optionally send to dead-letter stream
  await this.sendToDeadLetterStream(event, validationResult.errors);
  
  // Don't acknowledge - let it retry or expire
  // OR acknowledge with error flag for monitoring
}
```

---

## Summary

### Recommended Decisions

1. **Event Format**: Use the unified format above (compatible with existing patterns)
2. **Role Permissions**: Include nested `permissions` object + optional `flatPermissions` array
3. **Consumer Groups**: Use `crm-consumers:{stream-type}:{tenant-id}` format
4. **Validation**: Implement comprehensive validation at publisher and consumer levels

### Migration Path

1. **Phase 1**: Implement unified event format in new code
2. **Phase 2**: Add validation layer
3. **Phase 3**: Migrate existing publishers to new format
4. **Phase 4**: Update consumers to handle both formats (backward compatibility)
5. **Phase 5**: Deprecate old formats

### Next Steps

1. Create `EventValidator` utility class
2. Create `EventPublisher` wrapper that enforces format
3. Update role permissions change events to use new format
4. Add consumer group management utilities
5. Add monitoring/alerting for validation failures


